if(sum(edges.candidate.tracking$flip.candidate)==0){
test.candidate <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root)
test.candidate$flips <- sum(edges.candidate.tracking$flipped)
return(test.candidate[0,])
} else {
# Otherwise, iterate recursively over all possible pathways
# Find the row indexes for the new candidates
new.candidates <- as.numeric(rownames(edges.candidate.tracking[edges.candidate.tracking$flip.candidate==1,]))
# Run the function for all of the new candidates
output <- do.call("rbind",lapply(1:length(new.candidates),function(x) MBD.search.recursive.at.depth(edges.candidate.tracking,new.candidates[x],depth.target=depth.target,search.direction=search.direction)))
return(output)
}
}
}
# Run for each edge that isn't fixed
unfixed.edges <- c(1:nrow(edges.root.tracking))[edges.root.tracking$fixed.direction==0]
MBDs <- unique(do.call("rbind",lapply(unfixed.edges,function(x) MBD.search.recursive.outer(edges.root.tracking,x))))
}
# Combine into one big set of branch DAGs
DAGs.tested <- rbind(UEBDs,MBDs)
DAGs.branch <- DAGs.tested[DAGs.tested$verdict=="Passed",]
# Export
return(list("DAGs.branch" = DAGs.branch,"DAGs.tested"=DAGs.tested))
}
test.dw.obj <- dagwood(DAG.root,exposure,outcome)
# Identify misdirection branch DAGs
{
# Start with master edges list, adding column for whether or not edge has been flipped
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking$v <- as.character(edges.root.tracking$v)
edges.root.tracking$e <- as.character(edges.root.tracking$e)
edges.root.tracking$w <- as.character(edges.root.tracking$w)
edges.root.tracking$e.orig <- edges.root.tracking$e
# Generate columns to keep track of what has been flipped and what is available as a candidate to flip
edges.root.tracking$flipped <- 0
edges.root.tracking$flip.candidate <- 0
edges.root.tracking$distance <- 0
# Add information in for any fixed arrows
if (!is.na(fixed.arrows)){
edges.root.fixed <- edges(dagitty(dagitty(paste0("dag {",fixed.arrows,"}"))))[c("v","w","e")]
edges.root.fixed$fixed.arrow <- 1
edges.root.tracking <- merge(edges.root.tracking,edges.root.fixed,by=c("v","e","w"),all.x=TRUE,all.y=FALSE)
edges.root.tracking$fixed.arrow <- ifelse(is.na(edges.root.tracking$fixed.arrow),0,edges.root.tracking$fixed.arrow)
} else {
edges.root.tracking$fixed.arrow <- 0
}
# Recursive function for searching for MBDs
MBD.search.recursive.outer <- function(edges.candidate.tracking,index.edge,depth=1,search.direction="downstream"){
# First, attempt to find matches at current depth
tests.at.level <- MBD.search.recursive.at.depth(edges.candidate.tracking=edges.candidate.tracking,i=index.edge,depth.target=depth,search.direction=search.direction)
# If it passes (or returns a blank), return the output
if (any(tests.at.level$verdict=="Passed")|nrow(tests.at.level)==0){
return(tests.at.level)
} else {
# If not, iterate and run the next level
return(MBD.search.recursive.outer(edges.candidate.tracking,index.edge,depth=depth+1))
}
}
# Recursive function for searching for MBDs, searching until it hits a target depth
MBD.search.recursive.at.depth <- function(edges.candidate.tracking,i,depth.target,search.direction="downstream"){
# First, reset the flip candidates to 0
edges.candidate.tracking$flip.candidate <- 0
# Flip an edge
if(edges.candidate.tracking$e[i] == "->"){
edges.candidate.tracking$e[i] <- "<-"
node.target.new <- edges.candidate.tracking$v[i]
node.trailing.new <- edges.candidate.tracking$w[i]
} else {
edges.candidate.tracking$e[i] <- "->"
node.target.new <- edges.candidate.tracking$w[i]
node.trailing.new <- edges.candidate.tracking$v[i]
}
edges.candidate.tracking$flipped[i] <- 1
# Convert to dagitty form
DAG.branch.candidate <- dagitty::dagitty(paste0("dag {",paste(paste0(edges.candidate.tracking$v,edges.candidate.tracking$e,edges.candidate.tracking$w),collapse="\n"),"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
# Collect all changes for reporting
recording.temp <- edges.candidate.tracking[edges.candidate.tracking$flipped==1,]
changes.made <- paste(paste0(recording.temp$v,recording.temp$e,recording.temp$w),collapse=", ")
# Test to see if this change results in a valid DAGWOOD branch DAG
# Only test at target depth
if (sum(edges.candidate.tracking$flipped)==depth.target){
test.candidate <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "MBD",changes.made=paste0("Flipped ",changes.made))
return(test.candidate)
} else {
# If not yet at target depth, iterate to find more flip candidates
if (search.direction == "downstream"){
# Find all of edges connected to the new target edge which are unflipped and not fixed
edges.candidate.tracking$flip.candidate <- ifelse((edges.candidate.tracking$w==node.target.new | edges.candidate.tracking$v==node.target.new) &
edges.candidate.tracking$flipped==0 & edges.candidate.tracking$fixed.arrow == 0,
1,0)
} else if (search.direction == "bidirectional") {
# Find all of edges connected to either side of the newly flipped edge which are unflipped and not fixed
edges.candidate.tracking$flip.candidate <- ifelse((edges.candidate.tracking$w==node.target.new | edges.candidate.tracking$v==node.target.new | edges.candidate.tracking$w==node.trailing.new | edges.candidate.tracking$v==node.trailing.new) &
edges.candidate.tracking$flipped==0 & edges.candidate.tracking$fixed.arrow == 0,
1,0)
}
# If nothing is available, return an empty set
if(sum(edges.candidate.tracking$flip.candidate)==0){
test.candidate <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root)
test.candidate$flips <- sum(edges.candidate.tracking$flipped)
return(test.candidate[0,])
} else {
# Otherwise, iterate recursively over all possible pathways
# Find the row indexes for the new candidates
new.candidates <- as.numeric(rownames(edges.candidate.tracking[edges.candidate.tracking$flip.candidate==1,]))
# Run the function for all of the new candidates
output <- do.call("rbind",lapply(1:length(new.candidates),function(x) MBD.search.recursive.at.depth(edges.candidate.tracking,new.candidates[x],depth.target=depth.target,search.direction=search.direction)))
return(output)
}
}
}
# Run for each edge that isn't fixed
unfixed.edges <- c(1:nrow(edges.root.tracking))[edges.root.tracking$fixed.direction==0]
MBDs <- unique(do.call("rbind",lapply(unfixed.edges,function(x) MBD.search.recursive.outer(edges.root.tracking,x))))
}
DAG.root <-"Chocolate -> Alzheimers
Chocolate <- Education -> Alzheimers
Chocolate -> CV
CV -> Alzheimers"
exposure <- "Chocolate"
outcome <- "Alzheimers"
{
# Check if the formula provided is a dagitty object, and fill in appropriately
if(dagitty::is.dagitty(DAG.root)){
DAG.root <- DAG.root
if (length(dagitty::exposures(DAG.root))==0){
dagitty::exposures(DAG.root) <- exposure
} else {
exposure <- dagitty::exposures(DAG.root)
}
if (length(dagitty::outcomes(DAG.root))==0){
dagitty::outcomes(DAG.root) <- outcomes
} else {
outcome <- dagitty::outcomes(DAG.root)
}
DAG.root <- paste0(edges(DAG.root)$v,edges(DAG.root)$e,edges(DAG.root)$w,collapse=" \n ")
} else {
DAG.root <- dagitty(paste0("dag {",DAG.root,"}"))
dagitty::exposures(DAG.root) <- exposure
dagitty::outcomes(DAG.root) <- outcome
}
}
# Properties of the root DAG
nodes.root <- names(DAG.root)
edges.root <- dagitty::edges(DAG.root)
# Properties of the KEBDs (if any), set aside for later (not part of the root DAG)
if (!is.na(KEBDs)){
DAG.root.KEBDs <- dagitty(paste0("dag {",paste0(DAG.root,"\n",KEBDs,"}")))
nodes.root.KEBDs <- names(DAG.root.KEBDs)
nodes.KEBDs <- nodes.root.KEBDs[!nodes.root.KEBDs %in% nodes.root]
}
# Identify exclusion branch DAGs
{
# Find every combinatorial of nodes
combs <- utils::combn(nodes.root,2)
n.combs <- ncol(combs)
# Function for testing if valid DAGWOOD object, taking a branch DAG (root DAG in memory)
test.single.UEBD.comb <- function(i){
nodes.UEBD.temp <- combs[,i]
# Three possibilities: ->, <-, or <-UEBD->
# First, try -> and test
addition <- paste0(nodes.UEBD.temp[1],"->",nodes.UEBD.temp[2])
DAG.branch.candidate <- dagitty::dagitty(paste0("dag {",DAG.root,"\n",addition,"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
forward <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "ER",changes.made=paste0("Added ",addition))
forward <- forward[forward$verdict=="Passed",]
# First, try <- and test
addition <- paste0(nodes.UEBD.temp[1],"<-",nodes.UEBD.temp[2])
DAG.branch.candidate <- dagitty(paste0("dag {",DAG.root,"\n",addition,"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
backward <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "ER",changes.made=paste0("Added ",addition))
backward <- backward[backward$verdict=="Passed",]
# Lastly, try <-UEBD-> and test
addition <- paste0(nodes.UEBD.temp[1],"<-UEBD->",nodes.UEBD.temp[2])
DAG.branch.candidate <- dagitty(paste0("dag {",DAG.root,"\n",addition,"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
bidirectional <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "ER",changes.made=paste0("Added ",addition))
bidirectional <- bidirectional[bidirectional$verdict=="Passed",]
# Finally, merge into one data frame
output <- rbind(forward,backward,bidirectional)
return(output)
}
UEBDs <- do.call("rbind",lapply(1:n.combs,function(x) test.single.UEBD.comb(x)))
#UEBDs <- UEBDs[UEBDs$verdict=="Passed",]
}
# Identify misdirection branch DAGs
{
# Start with master edges list, adding column for whether or not edge has been flipped
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking$v <- as.character(edges.root.tracking$v)
edges.root.tracking$e <- as.character(edges.root.tracking$e)
edges.root.tracking$w <- as.character(edges.root.tracking$w)
edges.root.tracking$e.orig <- edges.root.tracking$e
# Generate columns to keep track of what has been flipped and what is available as a candidate to flip
edges.root.tracking$flipped <- 0
edges.root.tracking$flip.candidate <- 0
edges.root.tracking$distance <- 0
# Add information in for any fixed arrows
if (!is.na(fixed.arrows)){
edges.root.fixed <- edges(dagitty(dagitty(paste0("dag {",fixed.arrows,"}"))))[c("v","w","e")]
edges.root.fixed$fixed.arrow <- 1
edges.root.tracking <- merge(edges.root.tracking,edges.root.fixed,by=c("v","e","w"),all.x=TRUE,all.y=FALSE)
edges.root.tracking$fixed.arrow <- ifelse(is.na(edges.root.tracking$fixed.arrow),0,edges.root.tracking$fixed.arrow)
} else {
edges.root.tracking$fixed.arrow <- 0
}
# Recursive function for searching for MBDs
MBD.search.recursive.outer <- function(edges.candidate.tracking,index.edge,depth=1,search.direction="downstream"){
# First, attempt to find matches at current depth
tests.at.level <- MBD.search.recursive.at.depth(edges.candidate.tracking=edges.candidate.tracking,i=index.edge,depth.target=depth,search.direction=search.direction)
# If it passes (or returns a blank), return the output
if (any(tests.at.level$verdict=="Passed")|nrow(tests.at.level)==0){
return(tests.at.level)
} else {
# If not, iterate and run the next level
return(MBD.search.recursive.outer(edges.candidate.tracking,index.edge,depth=depth+1))
}
}
# Recursive function for searching for MBDs, searching until it hits a target depth
MBD.search.recursive.at.depth <- function(edges.candidate.tracking,i,depth.target,search.direction="downstream"){
# First, reset the flip candidates to 0
edges.candidate.tracking$flip.candidate <- 0
# Flip an edge
if(edges.candidate.tracking$e[i] == "->"){
edges.candidate.tracking$e[i] <- "<-"
node.target.new <- edges.candidate.tracking$v[i]
node.trailing.new <- edges.candidate.tracking$w[i]
} else {
edges.candidate.tracking$e[i] <- "->"
node.target.new <- edges.candidate.tracking$w[i]
node.trailing.new <- edges.candidate.tracking$v[i]
}
edges.candidate.tracking$flipped[i] <- 1
# Convert to dagitty form
DAG.branch.candidate <- dagitty::dagitty(paste0("dag {",paste(paste0(edges.candidate.tracking$v,edges.candidate.tracking$e,edges.candidate.tracking$w),collapse="\n"),"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
# Collect all changes for reporting
recording.temp <- edges.candidate.tracking[edges.candidate.tracking$flipped==1,]
changes.made <- paste(paste0(recording.temp$v,recording.temp$e,recording.temp$w),collapse=", ")
# Test to see if this change results in a valid DAGWOOD branch DAG
# Only test at target depth
if (sum(edges.candidate.tracking$flipped)==depth.target){
test.candidate <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "MBD",changes.made=paste0("Flipped ",changes.made))
return(test.candidate)
} else {
# If not yet at target depth, iterate to find more flip candidates
if (search.direction == "downstream"){
# Find all of edges connected to the new target edge which are unflipped and not fixed
edges.candidate.tracking$flip.candidate <- ifelse((edges.candidate.tracking$w==node.target.new | edges.candidate.tracking$v==node.target.new) &
edges.candidate.tracking$flipped==0 & edges.candidate.tracking$fixed.arrow == 0,
1,0)
} else if (search.direction == "bidirectional") {
# Find all of edges connected to either side of the newly flipped edge which are unflipped and not fixed
edges.candidate.tracking$flip.candidate <- ifelse((edges.candidate.tracking$w==node.target.new | edges.candidate.tracking$v==node.target.new | edges.candidate.tracking$w==node.trailing.new | edges.candidate.tracking$v==node.trailing.new) &
edges.candidate.tracking$flipped==0 & edges.candidate.tracking$fixed.arrow == 0,
1,0)
}
# If nothing is available, return an empty set
if(sum(edges.candidate.tracking$flip.candidate)==0){
test.candidate <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root)
test.candidate$flips <- sum(edges.candidate.tracking$flipped)
return(test.candidate[0,])
} else {
# Otherwise, iterate recursively over all possible pathways
# Find the row indexes for the new candidates
new.candidates <- as.numeric(rownames(edges.candidate.tracking[edges.candidate.tracking$flip.candidate==1,]))
# Run the function for all of the new candidates
output <- do.call("rbind",lapply(1:length(new.candidates),function(x) MBD.search.recursive.at.depth(edges.candidate.tracking,new.candidates[x],depth.target=depth.target,search.direction=search.direction)))
return(output)
}
}
}
# Run for each edge that isn't fixed
unfixed.edges <- c(1:nrow(edges.root.tracking))[edges.root.tracking$fixed.direction==0]
MBDs <- unique(do.call("rbind",lapply(unfixed.edges,function(x) MBD.search.recursive.outer(edges.root.tracking,x))))
}
View(UEBDs)
test.dw.obj <- dagwood(formula.DAG,exposure,outcome)
test.dw.obj <- dagwood(DAG.root,exposure,outcome)
# Start with master edges list, adding column for whether or not edge has been flipped
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking$v <- as.character(edges.root.tracking$v)
edges.root.tracking$e <- as.character(edges.root.tracking$e)
edges.root.tracking$w <- as.character(edges.root.tracking$w)
edges.root.tracking$e.orig <- edges.root.tracking$e
# Generate columns to keep track of what has been flipped and what is available as a candidate to flip
edges.root.tracking$flipped <- 0
edges.root.tracking$flip.candidate <- 0
edges.root.tracking$distance <- 0
# Add information in for any fixed arrows
if (!is.na(fixed.arrows)){
edges.root.fixed <- edges(dagitty(dagitty(paste0("dag {",fixed.arrows,"}"))))[c("v","w","e")]
edges.root.fixed$fixed.arrow <- 1
edges.root.tracking <- merge(edges.root.tracking,edges.root.fixed,by=c("v","e","w"),all.x=TRUE,all.y=FALSE)
edges.root.tracking$fixed.arrow <- ifelse(is.na(edges.root.tracking$fixed.arrow),0,edges.root.tracking$fixed.arrow)
} else {
edges.root.tracking$fixed.arrow <- 0
}
# Run for each edge that isn't fixed
unfixed.edges <- c(1:nrow(edges.root.tracking))[edges.root.tracking$fixed.direction==0]
unfixed.edges
edges.root.tracking
# Run for each edge that isn't fixed
unfixed.edges <- c(1:nrow(edges.root.tracking))[edges.root.tracking$fixed.direction==0]
unfixed.edges
edges.root.tracking$fixed.direction
edges.root.tracking
# Run for each edge that isn't fixed
unfixed.edges <- c(1:nrow(edges.root.tracking))[edges.root.tracking$fixed.arrow==0]
unfixed.edges
# Main DAGWOOD function
dagwood <- function(DAG.root,exposure=NA,outcome=NA,KEBDs=NA,instrument=NA,fixed.arrows=NA){
# Clean up formula/dagitty objects
{
# Check if the formula provided is a dagitty object, and fill in appropriately
if(dagitty::is.dagitty(DAG.root)){
DAG.root <- DAG.root
if (length(dagitty::exposures(DAG.root))==0){
dagitty::exposures(DAG.root) <- exposure
} else {
exposure <- dagitty::exposures(DAG.root)
}
if (length(dagitty::outcomes(DAG.root))==0){
dagitty::outcomes(DAG.root) <- outcomes
} else {
outcome <- dagitty::outcomes(DAG.root)
}
DAG.root <- paste0(edges(DAG.root)$v,edges(DAG.root)$e,edges(DAG.root)$w,collapse=" \n ")
} else {
DAG.root <- dagitty(paste0("dag {",DAG.root,"}"))
dagitty::exposures(DAG.root) <- exposure
dagitty::outcomes(DAG.root) <- outcome
}
}
# Properties of the root DAG
nodes.root <- names(DAG.root)
edges.root <- dagitty::edges(DAG.root)
# Properties of the KEBDs (if any), set aside for later (not part of the root DAG)
if (!is.na(KEBDs)){
DAG.root.KEBDs <- dagitty(paste0("dag {",paste0(DAG.root,"\n",KEBDs,"}")))
nodes.root.KEBDs <- names(DAG.root.KEBDs)
nodes.KEBDs <- nodes.root.KEBDs[!nodes.root.KEBDs %in% nodes.root]
}
# Identify exclusion branch DAGs
{
# Find every combinatorial of nodes
combs <- utils::combn(nodes.root,2)
n.combs <- ncol(combs)
# Function for testing if valid DAGWOOD object, taking a branch DAG (root DAG in memory)
test.single.UEBD.comb <- function(i){
nodes.UEBD.temp <- combs[,i]
# Three possibilities: ->, <-, or <-UEBD->
# First, try -> and test
addition <- paste0(nodes.UEBD.temp[1],"->",nodes.UEBD.temp[2])
DAG.branch.candidate <- dagitty::dagitty(paste0("dag {",DAG.root,"\n",addition,"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
forward <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "ER",changes.made=paste0("Added ",addition))
forward <- forward[forward$verdict=="Passed",]
# First, try <- and test
addition <- paste0(nodes.UEBD.temp[1],"<-",nodes.UEBD.temp[2])
DAG.branch.candidate <- dagitty(paste0("dag {",DAG.root,"\n",addition,"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
backward <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "ER",changes.made=paste0("Added ",addition))
backward <- backward[backward$verdict=="Passed",]
# Lastly, try <-UEBD-> and test
addition <- paste0(nodes.UEBD.temp[1],"<-UEBD->",nodes.UEBD.temp[2])
DAG.branch.candidate <- dagitty(paste0("dag {",DAG.root,"\n",addition,"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
bidirectional <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "ER",changes.made=paste0("Added ",addition))
bidirectional <- bidirectional[bidirectional$verdict=="Passed",]
# Finally, merge into one data frame
output <- rbind(forward,backward,bidirectional)
return(output)
}
UEBDs <- do.call("rbind",lapply(1:n.combs,function(x) test.single.UEBD.comb(x)))
#UEBDs <- UEBDs[UEBDs$verdict=="Passed",]
}
# Identify misdirection branch DAGs
{
# Start with master edges list, adding column for whether or not edge has been flipped
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking <- edges.root[c("v","e","w")]
edges.root.tracking$v <- as.character(edges.root.tracking$v)
edges.root.tracking$e <- as.character(edges.root.tracking$e)
edges.root.tracking$w <- as.character(edges.root.tracking$w)
edges.root.tracking$e.orig <- edges.root.tracking$e
# Generate columns to keep track of what has been flipped and what is available as a candidate to flip
edges.root.tracking$flipped <- 0
edges.root.tracking$flip.candidate <- 0
edges.root.tracking$distance <- 0
# Add information in for any fixed arrows
if (!is.na(fixed.arrows)){
edges.root.fixed <- edges(dagitty(dagitty(paste0("dag {",fixed.arrows,"}"))))[c("v","w","e")]
edges.root.fixed$fixed.arrow <- 1
edges.root.tracking <- merge(edges.root.tracking,edges.root.fixed,by=c("v","e","w"),all.x=TRUE,all.y=FALSE)
edges.root.tracking$fixed.arrow <- ifelse(is.na(edges.root.tracking$fixed.arrow),0,edges.root.tracking$fixed.arrow)
} else {
edges.root.tracking$fixed.arrow <- 0
}
# Recursive function for searching for MBDs
MBD.search.recursive.outer <- function(edges.candidate.tracking,index.edge,depth=1,search.direction="downstream"){
# First, attempt to find matches at current depth
tests.at.level <- MBD.search.recursive.at.depth(edges.candidate.tracking=edges.candidate.tracking,i=index.edge,depth.target=depth,search.direction=search.direction)
# If it passes (or returns a blank), return the output
if (any(tests.at.level$verdict=="Passed")|nrow(tests.at.level)==0){
return(tests.at.level)
} else {
# If not, iterate and run the next level
return(MBD.search.recursive.outer(edges.candidate.tracking,index.edge,depth=depth+1))
}
}
# Recursive function for searching for MBDs, searching until it hits a target depth
MBD.search.recursive.at.depth <- function(edges.candidate.tracking,i,depth.target,search.direction="downstream"){
# First, reset the flip candidates to 0
edges.candidate.tracking$flip.candidate <- 0
# Flip an edge
if(edges.candidate.tracking$e[i] == "->"){
edges.candidate.tracking$e[i] <- "<-"
node.target.new <- edges.candidate.tracking$v[i]
node.trailing.new <- edges.candidate.tracking$w[i]
} else {
edges.candidate.tracking$e[i] <- "->"
node.target.new <- edges.candidate.tracking$w[i]
node.trailing.new <- edges.candidate.tracking$v[i]
}
edges.candidate.tracking$flipped[i] <- 1
# Convert to dagitty form
DAG.branch.candidate <- dagitty::dagitty(paste0("dag {",paste(paste0(edges.candidate.tracking$v,edges.candidate.tracking$e,edges.candidate.tracking$w),collapse="\n"),"}"))
dagitty::exposures(DAG.branch.candidate) <- exposure
dagitty::outcomes(DAG.branch.candidate) <- outcome
# Collect all changes for reporting
recording.temp <- edges.candidate.tracking[edges.candidate.tracking$flipped==1,]
changes.made <- paste(paste0(recording.temp$v,recording.temp$e,recording.temp$w),collapse=", ")
# Test to see if this change results in a valid DAGWOOD branch DAG
# Only test at target depth
if (sum(edges.candidate.tracking$flipped)==depth.target){
test.candidate <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root,instrument=instrument,BD.type = "MBD",changes.made=paste0("Flipped ",changes.made))
return(test.candidate)
} else {
# If not yet at target depth, iterate to find more flip candidates
if (search.direction == "downstream"){
# Find all of edges connected to the new target edge which are unflipped and not fixed
edges.candidate.tracking$flip.candidate <- ifelse((edges.candidate.tracking$w==node.target.new | edges.candidate.tracking$v==node.target.new) &
edges.candidate.tracking$flipped==0 & edges.candidate.tracking$fixed.arrow == 0,
1,0)
} else if (search.direction == "bidirectional") {
# Find all of edges connected to either side of the newly flipped edge which are unflipped and not fixed
edges.candidate.tracking$flip.candidate <- ifelse((edges.candidate.tracking$w==node.target.new | edges.candidate.tracking$v==node.target.new | edges.candidate.tracking$w==node.trailing.new | edges.candidate.tracking$v==node.trailing.new) &
edges.candidate.tracking$flipped==0 & edges.candidate.tracking$fixed.arrow == 0,
1,0)
}
# If nothing is available, return an empty set
if(sum(edges.candidate.tracking$flip.candidate)==0){
test.candidate <- test.DAG.branch.candidate(DAG.branch.candidate = DAG.branch.candidate,DAG.root=DAG.root)
test.candidate$flips <- sum(edges.candidate.tracking$flipped)
return(test.candidate[0,])
} else {
# Otherwise, iterate recursively over all possible pathways
# Find the row indexes for the new candidates
new.candidates <- as.numeric(rownames(edges.candidate.tracking[edges.candidate.tracking$flip.candidate==1,]))
# Run the function for all of the new candidates
output <- do.call("rbind",lapply(1:length(new.candidates),function(x) MBD.search.recursive.at.depth(edges.candidate.tracking,new.candidates[x],depth.target=depth.target,search.direction=search.direction)))
return(output)
}
}
}
# Run for each edge that isn't fixed
unfixed.edges <- c(1:nrow(edges.root.tracking))[edges.root.tracking$fixed.arrow==0]
MBDs <- unique(do.call("rbind",lapply(unfixed.edges,function(x) MBD.search.recursive.outer(edges.root.tracking,x))))
}
# Combine into one big set of branch DAGs
DAGs.tested <- rbind(UEBDs,MBDs)
DAGs.branch <- DAGs.tested[DAGs.tested$verdict=="Passed",]
# Export
return(list("DAGs.branch" = DAGs.branch,"DAGs.tested"=DAGs.tested))
}
DAG.root <-"Chocolate -> Alzheimers
Chocolate <- Education -> Alzheimers
Chocolate -> CV
CV -> Alzheimers"
exposure <- "Chocolate"
outcome <- "Alzheimers"
test.dw.obj <- dagwood(DAG.root,exposure,outcome)
test.dw.obj$DAGs.branch
fixed.arrows <- "Chocolate -> Alzheimers"
fixed.arrows <- "Education -> Alzheimers"
test.dw.obj.fixed <- dagwood(DAG.root,exposure,outcome,fixed.arrows)
test.dw.obj.BD <- test.dw.obj$DAGs.branch
test.dw.obj.fixed.BD <- test.dw.obj.fixed$DAGs.branch
View(test.dw.obj.BD)
View(test.dw.obj.fixed.BD)
test.dw.obj.fixed <- dagwood(DAG.root,exposure,outcome,fixed.arrows=fixed.arrows)
test.dw.obj.fixed.BD <- test.dw.obj.fixed$DAGs.branch
View(test.dw.obj.fixed.BD)
document()
rm(list=ls())
library(devtools)
library(roxygen2)
setwd("C:/Users/noahh/Google Drive/DAGWOOD/Package/dagwood")
document()
